<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
		<!ENTITY % darktable_dtd SYSTEM "../dtd/darktable.dtd">
		%darktable_dtd;
		]>
<sect1 status="final" id="darktable_and_opencl">

  <title>darktable and OpenCL</title>

  <indexterm>
    <primary>OpenCL</primary>
  </indexterm>

  <indexterm>
    <primary>GPU computing</primary>
  </indexterm>

  <para>
    darktable can use GPU acceleration via OpenCL to improve performance.
  </para>

  <sect2 status="final">

    <title>The background</title>

    <para>
      Processing high resolution images is a demanding task needing a modern computer. Both in
      terms of memory requirements and in terms of CPU power, getting the best out of a typical
      15, 20 or 25 Megapixel image can quickly bring your computer to its limits.
    </para>

    <para>
      darktable's requirements are no exception. Our decision to not compromise processing
      quality, has led to all calculations being done on 4 x 32bit floating point numbers. This
      is slower than <quote>ordinary</quote> 8 or 16bit integer algebra, but eliminates all
      problems of tonal breaks or loss of information.
    </para>

    <para>
      A lot of hand optimization has been invested to make darktable as fast as possible. If you
      run a current version of darktable on a modern computer, you might not notice any
      <quote>slowness</quote>. However, there are conditions and certain modules where you will
      feel (or hear from the howling of your CPU fan) how much your poor multi-core processor
      has to struggle.
    </para>

    <para>
      That's where OpenCL comes in. OpenCL allows us to take advantage of the enormous power of
      modern graphics cards. Gamer's demand for high detailed 3D worlds in modern ego shooters
      has fostered GPU development. ATI, NVIDIA and Co had to put enormous processing power into
      their GPUs to meet these demands. The result is modern graphics cards with highly
      parallelized GPUs to quickly calculate surfaces and textures at high frame rates.
    </para>

    <para>
      You are not a gamer and you don't take advantage of that power? Well, then you should at
      least use it in darktable! For the task of highly parallel floating point calculations
      modern GPUs are much faster than CPUs. That is especially true, when you want to do the
      same few processing steps over millions of items. Typical use case: processing of
      megapixel images.
    </para>

  </sect2>

  <sect2 status="final">

    <title>How OpenCL works</title>

    <para>
      As you can imagine, hardware architectures of GPUs can vary significantly. There are
      different manufacturers, and even different generations of GPUs from the same manufacturer
      may differ. At the same time GPU manufacturers don't normally disclose all hardware
      details of their products to the public. One of the known consequences is the need to use
      proprietary drivers under Linux, if you want to take full advantage of your graphics card.
    </para>

    <para>
      Fortunately an industry consortium lead by The Khronos Group has developed an open,
      standardized interface called OpenCL. It allows the use of your GPU as a numerical
      processing device. OpenCL offers a C99-like programming language with a strong focus on
      parallel computing. An application that wants to use OpenCL will need OpenCL source code
      that it hands over to a hardware specific OpenCL compiler at run-time. This way the
      application can use OpenCL on different GPU architectures (even at the same time). All
      hardware <quote>secrets</quote> are hidden in this compiler and are normally not visible
      to the user (or the application). The compiled OpenCL code is loaded onto your GPU
      and&nbsp;&ndash; with certain API calls&nbsp;&ndash; it is ready to do calculations for
      you.
    </para>

  </sect2>

  <sect2 status="final">

    <title>How to activate OpenCL in darktable</title>

    <para>
      Using OpenCL in darktable requires that your PC is equipped with a suitable graphics card
      and that it has the required libraries in place. Namely modern graphics cards from NVIDIA
      and ATI come with full OpenCL support. The OpenCL compiler is normally shipped as part of
      the proprietary graphics driver; it is used as a dynamic library called
      <quote>libOpenCL.so</quote>. This library must be in a folder where it is found by your
      system's dynamic linker.
    </para>

    <para>
      When darktable starts, it will first try to find and load libOpenCL.so and&nbsp;&ndash; on
      success&nbsp;&ndash; check if the available graphics card comes with OpenCL support. A
      sufficient amount of graphics memory (1GB+) needs to be available to take advantage of the
      GPU. If that is OK, darktable tries to setup its OpenCL environment: a processing context
      needs to be initialized, a calculation pipeline to be started, OpenCL source code files
      (extension is .cl) need to be read and compiled and the included routines (called OpenCL
      kernels) need to be prepared for darktablele's modules. If all that is done, the
      preparation is finished.
    </para>

    <para>
      Per default OpenCL support is activated in darktable if all the above steps were
      successful. If you want to de-activate it you can do so in <quote>core options</quote>
      (<xref linkend="core_options"/>) by unchecking <quote>activate opencl support</quote>.
      This configuration parameter also tells you if OpenCL initialization failed: it is greyed
      out in that case.
    </para>

    <para>
      You can at any time switch OpenCL support off and on; this will happen immediately.
      Depending on the type of modules you are using, you will notice the effect as a general
      speed-up during interactive work and during export. Most modules in darktable can take
      advantage of OpenCL but not all modules are demanding enough to make a noticeable
      difference. In order to feel a real difference, take modules like
      <link linkend="shadows_and_highlights"><emphasis>shadows and highlights</emphasis></link>,
      <link linkend="sharpen"><emphasis>sharpen</emphasis></link>,
      <link linkend="lowpass"><emphasis>lowpass</emphasis></link>,
      <link linkend="lowpass"><emphasis>highpass</emphasis></link> or even more extreme
      <link linkend="equalizer"><emphasis>equalizer</emphasis></link> and
      <link linkend="denoise_profiled"><emphasis>profiled denoise</emphasis></link>.
    </para>

    <para>
      If you are interested in profiling figures, you can start darktable with command line
      parameters <quote>-d opencl -d perf</quote>. After each run of the pixelpipe you will get
      a detailed allocation of processing time to each module plus an even more fine grained
      profile for all used OpenCL kernels.
    </para>

    <para>
      Besides the speed-up you should not see any difference in the results between CPU and GPU
      processing. Except of rounding errors, the results are designed to be identical. If, for
      some reasons, darktable fails to properly finish a GPU calculation, it will normally
      notice and automatically (and transparently) fall back to CPU processing.
    </para>

  </sect2>

  <sect2 status="final">

    <title>Setting up OpenCL on your system</title>

    <para>
      The huge diversity of systems and the marked differences between OpenCL vendors and driver
      versions makes it impossible to give an comprehensive overview of how to setup OpenCL. We
      only can give you an example, in this case for NVIDIA driver version 331.89 on Ubuntu
      14.04. We hope that this will serve you as a first impression and will help to solve
      possible problems of your specific setup.
    </para>

    <para>
      The principle OpenCL function flow is like this:
    </para>

    <para>
      darktable -> libOpenCL.so -> libnvidia-opencl.so.1 -> kernel driver module(s) -> GPU
    </para>

    <para>
      <itemizedlist>

        <listitem><para>
          darktable dynamically links <filename>libOpenCL.so</filename>, a system library which
          must be accessible to the system's dynamic loader (<filename>ld.so</filename>).
        </para></listitem>

        <listitem><para>
          <filename>libOpenCL.so</filename> will read the vendor specific information file
          (<filename>/etc/OpenCL/vendors/nvidia.icd</filename>) to find the library which
          contains the vendor specific OpenCL implementation.
        </para></listitem>

        <listitem><para>
          The vendor specific OpenCL implementation comes as a library
          <filename>libnvidia-opencl.so.1</filename> (which in our case is a symbolic link to
          <filename>libnvidia-opencl.so.331.89</filename>).
        </para></listitem>

        <listitem><para>
          <filename>libnvidia-opencl.so.1</filename> needs to talk to the vendor specific kernel
          modules <filename>nvidia</filename> and <filename>nvidia_uvm</filename> via device
          special files <filename>/dev/nvidia0</filename>, <filename>/dev/nvidiactl</filename>,
          and <filename>/dev/nvidia-uvm</filename>.
        </para></listitem>

      </itemizedlist>
    </para>

    <para>
      At system startup the required device special files (/dev/nvidia*) need to be created. If
      this does not happen on your system by default, the easiest way to set them up and make
      sure all modules are loaded is installing the <filename>nvidia-modprobe</filename> package
      (which, at the time of this writing, is only available for <quote>utopic</quote>, but
      works well with <quote>trusty</quote> and <quote>Mint 17</quote>). You can grab it at
      <ulink url="http://packages.ubuntu.com/utopic/nvidia-modprobe">this site</ulink>.
    </para>

    <para>
      A user account which wants to make use of OpenCL from within darktable needs to have
      read-write access to NVIDIA's device special files. On some systems these files allow
      world read-write access by default, which avoids permission issues but might be debatable
      in terms of system security. Other systems restrict the access to a user group, e.g.
      <quote>video</quote>. In that case your user account has to be member of that group.
    </para>

    <para>
      To summarise, the packages which needed to be installed in this specific case were:
      <itemizedlist>

        <listitem><para>
          nvidia-331 (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          nvidia-331-dev (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          nvidia-331-uvm (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          nvidia-libopencl1-331 (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          nvidia-modprobe (340.24-1)
        </para></listitem>

        <listitem><para>
          nvidia-opencl-dev:amd64 (5.5.22-3ubuntu1)
        </para></listitem>

        <listitem><para>
          nvidia-opencl-icd-331 (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          nvidia-settings (340.24-0ubuntu1~xedgers14.04.1)
        </para></listitem>

        <listitem><para>
          nvidia-settings-304 (340.24-0ubuntu1~xedgers14.04.1)
        </para></listitem>

        <listitem><para>
          nvidia-libopencl1-331 (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          nvidia-opencl-dev:amd64 (5.5.22-3ubuntu1)
        </para></listitem>

        <listitem><para>
          nvidia-opencl-icd-331 (331.89-0ubuntu1~xedgers14.04.2)
        </para></listitem>

        <listitem><para>
          opencl-headers (1.2-2013.10.23-1)
        </para></listitem>

      </itemizedlist>
    </para>

    <para>
      The list of NVIDIA related kernel modules as reported by <filename>lsmod</filename> is:
    </para>

    <para>
<programlisting>nvidia
nvidia_uvm
</programlisting>
    </para>

    <para>
      The list of NVIDIA related device special files (<filename>ls -l /dev/nvidia*</filename>)
      should read like:
    </para>

    <para>
<programlisting>crw-rw-rw- 1 root root 195,   0 Jul 28 21:13 /dev/nvidia0
crw-rw-rw- 1 root root 195, 255 Jul 28 21:13 /dev/nvidiactl
crw-rw-rw- 1 root root 250,   0 Jul 28 21:13 /dev/nvidia-uvm 
</programlisting>
    </para>

    <para>
      Beware that the major/minor numbers (e.g. 250/0 for <filename>/dev/nvidia-uvm</filename>
      in this example) may vary depending on your system.
    </para>

  </sect2>

  <sect2 status="final">

    <title>Possible problems and solutions</title>

    <para>
      darktable will detect OpenCL run-time problems automatically. It will then reprocess
      everything on CPU; only speed is affected, the final result should not be endangered.
    </para>

    <para>
      There can be various reasons why OpenCL could fail during initialization phase. We depend
      on hardware requirements and on the presence of certain drivers and libraries. In addition
      all these have to fit in terms of maker model and revision number. If anything does not
      fit, e.g. your graphics driver (loaded as a kernel module) does not match the version of
      your libOpenCL.so, OpenCL support is likely not available.
    </para>

    <para>
      In that case, the best thing to do is start darktable from a console with
    </para>

    <para>
<programlisting>darktable -d opencl
</programlisting>
    </para>

    <para>
      This will give additional debugging output about the initialization and use of OpenCL.
      First see if you find a line that starts with <quote>[opencl_init] FINALLY ...</quote>
      This should tell you, if OpenCL support is available for you or not. If initialization
      failed, look at the messages above for anything that reads like <quote>could not be
      detected</quote> or <quote>could not be created</quote>. Check if there is a hint about
      where it failed.
    </para>

    <para>
      Here are a few cases observed in the past:
    </para>

    <itemizedlist>

      <listitem><para>
        darktable might tell you that no OpenCL aware graphics card is detected or that the
        available memory on your GPU is too low and the device is discarded. In that case you
        might need to buy a new card, if you really want OpenCL support.
      </para></listitem>

      <listitem><para>
        darktable might find your libOpenCL.so but then tell you that it couldn't get a
        platform. NVIDIA drivers will often give error code -1001 in that case. This happens
        because libOpenCL.so is only a wrapper library. For the real work further
        libraries&nbsp;&ndash; specific to vendor, device and driver&nbsp;&ndash; need to be
        loaded. This failed for some reason. There is a structure of files in /etc/OpenCL on
        your system that libOpenCL.so consults to find these libraries. Check if you find
        something fishy in there and try to fix it. Often the needed libraries cannot be found
        by your system's dynamic loader. Giving full path names might help.
      </para></listitem>

      <listitem><para>
        darktable might also tell you that a context could not be created. This often indicates
        a version mismatch between (loaded) graphics driver and libOpenCL. Check if you have
        left-over kernel modules or graphics libraries of an older install and take appropriate
        action. In doubt, make a clean reinstall of your graphics driver. Sometimes, immediately
        after a driver update, the loaded kernel driver does not match the newly installed
        libraries: reboot your system in that case.
      </para></listitem>

      <listitem><para>
        darktable might crash in very rare cases directly during startup. This can happen if
        your OpenCL setup is completely broken or if driver/library contains a severe bug. If
        you can't fix it, you can still use darktable with option
        <quote>--disable-opencl</quote>, which will skip the entire OpenCL initialization step.
      </para></listitem>

      <listitem><para>
        darktable might fail to compile its OpenCL source files at run-time. In that case you
        will get a number of error messages looking like typical compiler errors. This could
        indicate an incompatibility between your OpenCL implementation and our interpretation of
	the standard. In that case visit us in IRC in #darktable on FreeNode or on the developers
	mailing list at darktable-dev@lists.darktable.org and report the
        problem. Chances are good that we can help you. Please also report if you see
        significant differences between CPU and GPU processing of an image!
      </para></listitem>

    </itemizedlist>

    <para>
      There also exists a few on-CPU implementations of OpenCL. These come as drivers provided
      by INTEL or AMD. We observed that they do not give us any speed gain versus our
      hand-optimized CPU code. Therefore we simply discard these devices by default. This
      behavior can be changed by setting the configuration variable opencl_use_cpu_devices to
      TRUE.
    </para>

  </sect2>

  <sect2 status="final">

    <title>Setting up OpenCL for AMD/ATI devices</title>

    <para>
      While NVIDIA devices and most modern AMD/ATI devices will most often run out of the box,
      there is more to do for older AMD/ATI graphics cards, namely those prior to the HD7xxx
      series. This starts with the fact that those devices will only report to darktable part of
      their total GPU memory. For a 1GB device this typically amounts to 512MB, a value which
      darktable in its standard configuration will refuse as not being sufficient for its tasks.
      Consequence: the device will not be used.
    </para>

    <para>
      On the web you might find as a tip to set environment variable GPU_MAX_HEAP_SIZE to a
      value of 100 in this case. Indeed this will cause the AMD/ATI driver to report the full
      installed memory to darktable. However, there is a problem. On many (most?) cards this
      will cause buffers to be allocated on your computer (host) not on the video card! In this
      case all memory accesses will need to go through the slow PCIe bus. This will cost you a
      factor of 10x or more in performance and will render OpenCL useless for you, especially
      when exporting files.
    </para>

    <para>
      Another environment variable which changes driver behavior is GPU_MAX_ALLOC_PERCENT. You
      could set this to 100 in order to allow memory allocations as high as 1GB on your AMD/ATI
      card. The problem is, this tends to cause darktable to crash sooner or later.
    </para>

    <para>
      Our recommendation is to leave these settings untouched. Often your card will be
      recognized with 512MB memory and a maximum allocation size of 128MB. There are three
      configuration parameter which you set in file $HOME/.config/darktable/darktablerc to get
      things running. Here are the details:
      <variablelist>

        <varlistentry>

          <term>

            <computeroutput>opencl_memory_requirement</computeroutput>

          </term>

          <listitem><para>
            Set this parameter to 500 so that darktable will accept your 512MB graphics memory
            as being sufficient in memory.
          </para></listitem>

        </varlistentry>

        <varlistentry>

          <term>

            <computeroutput>opencl_memory_headroom</computeroutput>

          </term>

          <listitem><para>
            This parameter controls how much graphics memory (out of the reported one) darktable
            should leave untouched for driver and display use. As for AMD/ATI devices we anyhow
            only can get half of the available RAM it's safe to set this to zero. So all of the
            512MB can be used by darktable.
          </para></listitem>

        </varlistentry>

        <varlistentry>

          <term>

            <computeroutput>opencl_avoid_atomics</computeroutput>

          </term>

          <listitem><para>
            Atomic operations in OpenCL are a special way of data synchronization. They are only
            used in a few kernels. Unfortunately, some (most?) AMD/ATI devices are extremely
            slow in processing atomics. It's better to process the affected modules on CPU
            rather than accepting an ultra-slow GPU codepath. Set this parameter to TRUE if you
            experience slow processing of modules like
            <link linkend="shadows_and_highlights"><emphasis>shadows and
            highlights</emphasis></link>,
            <link linkend="monochrome"><emphasis>monochrome</emphasis></link>,
            <link linkend="local_contrast"><emphasis>local contrast</emphasis></link>, or
            <link linkend="global_tonemap"><emphasis>global tonemap</emphasis></link> or if you
            even get intermittent system freezes.
          </para></listitem>

        </varlistentry>

      </variablelist>
    </para>

    <para>
      These recommendations do not apply to the more recent Radeon HD7xxx series with GCN
      architecture. Besides being very fast in terms of GPU computing they normally run out of
      the box. You only might consider to try some of the performance optimization options which
      are described in the following section.
    </para>

  </sect2>

  <sect2 status="final">

    <title>OpenCL performance optimization</title>

    <para>
      There are some configuration parameters in $HOME/.config/darktable/darktablerc that help
      to finetune your system's OpenCL performance. Performance in this context mostly means the
      latency of darktable during interactive work, i.e. how long it takes to reprocess your
      pixelpipe. For a comfortable workflow it is essential to keep latency low.
    </para>

    <para>
      In order to get profiling info you start darktable from a terminal with
    </para>

    <para>
<programlisting>darktable -d opencl -d perf
</programlisting>
    </para>

    <para>
      After each reprocessing of pixelpipe&nbsp;&ndash; caused by module parameter change,
      zooming, panning, etc.&nbsp;&ndash; you will get the total time and the time spent in each
      of our OpenCL kernels. The most reliable value is the total time spent in pixelpipe.
      Please note that the timings given for each individual module are unreliable when running
      the OpenCL pixelpipe asynchronously (see opencl_async_pixelpipe below).
    </para>

    <para>
      To allow for a fast pixelpipe processing with OpenCL it is essential that we keep the GPU
      busy. Any interrupts or a stalled data flow will add to the total processing time. This is
      especially important for the small image buffers we need to handle during interactive
      work. They can be processed quickly by a fast GPU. However, even short-term stalls of the
      pixelpipe will easily become a bottleneck.
    </para>

    <para>
      On the other hand darktable's performance during file exports is more or less only
      governed by the speed of our algorithms and the horse-power of your GPU. Short-term stalls
      will not have a noticeable effect on the total time of an export.
    </para>

    <para>
      darktable comes with default settings that should deliver a decent GPU performance on most
      systems. However, if you want to fiddle around a bit by yourself and try to optimize
      things further, here is a description of the relevant configuration parameters.
      <variablelist>

        <varlistentry>

          <term>

            <computeroutput>opencl_async_pixelpipe</computeroutput>

          </term>

          <listitem><para>
            This boolean flag controls how often we block the OpenCL pixelpipe and get a status
            on success/failure of all the kernels that have been run. For optimum latency set
            this to TRUE, so darktable runs the pixelpipe asynchronously and tries to use as few
            interrupts as possible. If you experience OpenCL errors like failing kernels, set
            the parameter to FALSE. darktable will then interrupt after each module so you can
            more easily isolate the problem. Problems have been reported with some older ATI/AMD
            cards, like HD57xx, which can produce garbled output if this parameter is set to
            TRUE. If in doubt, leave it at its default FALSE.
          </para></listitem>

        </varlistentry>

        <varlistentry>

          <term>

            <computeroutput>opencl_number_event_handles</computeroutput>

          </term>

          <listitem><para>
            Event handles are used so we can monitor success/failure of kernels and profiling
            info even if the pixelpipe is run asynchronously. The number of event handles is a
            limited resource of your OpenCL driver. For sure we can recycle them, but there is a
            limited number that we can use at the same time. Unfortunately, there is no way to
            find out what the resource limits are; so we need to guess. Our default value of 25
            is quite conservative. You might want to try if higher values like 100 give better
            OpenCL performance. If your driver runs out of free handles you would experience
            failing OpenCL kernels with error code <quote>-5 (CL_OUT_OF_RESOURCES)</quote> or
            even crashes or system freezes; reduce the number again in that case. A value of 0
            will block darktable from using any event handles. This will prevent darktable from
            properly monitoring the success of your OpenCL kernels but saves some driver
            overhead. The consequence is that any failures will likely lead to garbled output
            without darktable taking notice; only recommended if you know for sure that your
            system runs rock-solid. You can also set this parameter to -1, which means that
            darktable assumes no restriction in the number of event handles; this is not
            recommended.
          </para></listitem>

        </varlistentry>

        <varlistentry>

          <term>

            <computeroutput>opencl_synch_cache</computeroutput>

          </term>

          <listitem><para>
            This parameter, if set to TRUE, will force darktable to fetch image buffers from
            your GPU after each module and store them in its pixelpipe cache. This is a very
            resource consuming operation. It only makes sense if you have a rather slow GPU. In
            that case darktable might in fact save some time when module parameters have
            changed, as it can go back to some cached intermediate state and reprocess only part
            of the pixelpipe. In most cases this parameter should be set to FALSE (default).
          </para></listitem>

        </varlistentry>

        <varlistentry>

          <term>

            <computeroutput>opencl_micro_nap</computeroutput>

          </term>

          <listitem><para>
            In an ideal case you keep your GPU busy at 100% when reprocessing the pixelpipe.
            That's good. On the other hand your GPU is also needed to do regular GUI updates. It
            might happen that there is no sufficient time left for this task. Consequence would
            by a jerky reaction of your GUI on panning, zooming or when moving sliders.
            darktable can add small naps into its pixelpipe processing to have the GPU catch
            some breath and do GUI related stuff. Parameter opencl_micro_nap controls the
            duration of these naps in microseconds. You need to experiment in order to find an
            optimum value for your system. Values of 0, 100, 500 and 1000 are good starting
            points to try. Defaults to 1000.
          </para></listitem>

        </varlistentry>

        <varlistentry>

          <term>

            <computeroutput>opencl_use_pinned_memory</computeroutput>

          </term>

          <listitem><para>
            During tiling huge amounts of memory need to be transferred between host and device.
            On some devices (namely AMD) direct memory transfers to and from an arbitrary host
            memory region may give a huge performance penalty. This is especially noticeable
            when exporting large images. Setting this configuration parameter to TRUE tells
            darktable to use a special kind of intermediate buffer for host-device data
            transfers. On some devices this can speed up exporting of large files by a factor of
            2 to 3. NVIDIA devices and drivers seem to have a more efficient memory transfer
            technique even for arbitrary memory regions. As they may not show any performance
            gain and even may produce garbled output, opencl_use_pinned_memory should be left at
            its default FALSE for those devices.
          </para></listitem>

        </varlistentry>

      </variablelist>
    </para>

  </sect2>

  <sect2 status="final">

    <title>Multiple OpenCL devices</title>

    <para>
      While most systems will only have one OpenCL capable GPU installed, darktable is also able
      to make use of multiple devices in parallel. There is a configuration parameter which
      helps to optimize GPU priorities in that case.
    </para>

    <para>
      It is important to understand how darktable uses OpenCL devices. Each processing sequence
      of an image&nbsp;&ndash; to convert an input to the final output using a certain history
      stack&nbsp;&ndash; is run in a so called pixelpipe. There are four different types of
      pixelpipe in darktable. One type is responsible to process the center image view (or full
      view) in darkroom mode, another pixelpipe processes the preview image (navigation window)
      top left in darkroom mode. Of each of these two pixelpipe there can be one at a
      time&nbsp;&ndash; with the full and the preview pixelpipe running in parallel. In addition
      there can be multiple parallel pixelpipes doing file exports and there can be multiple
      parallel pixelpipes generating thumbnails. If an OpenCL device is available darktable
      dynamically allocates it to one specific pixelpipe for one run and releases it afterwards.
    </para>

    <para>
      The computational demand depends a lot on the pixelpipe type. Preview image and thumbnails
      have a low resolution and can be processed quickly; center image view is more demanding,
      let alone the pixelpipe doing a file export. If you have a reasonably fast GPU and want to
      get a low latency during interactive work, it is therefore important that your GPU is
      allocated to do the more demanding center image (full) pixelpipe, while the smaller
      preview image can be processed in parallel by the CPU. Older versions of darktable would
      therefore not allow the preview pixelpipe to grab any OpenCL device.
    </para>

    <para>
      Starting with darktable 1.2 there is a more flexible scheme to allocate and prioritize
      your OpenCL device(s). Configuration parameter <quote>opencl_device_priority</quote> holds
      a string with the following structure:
    </para>

    <para>
<programlisting>a,b,c.../k,l,m.../o,p,q.../x,y,z...
</programlisting>
    </para>

    <para>
      Each letter represents one specific OpenCL device. There are four fields in the parameter
      string separated by a slash, each representing one type of pixelpipe.
      <quote>a,b,c...</quote> defines the devices that are allowed to process the center image
      (full) pixelpipe. Likewise devices <quote>k,l,m...</quote> can process the preview
      pixelpipe, devices <quote>o,p,q...</quote> the export pixelpipes and finally devices
      <quote>x,y,z...</quote> the thumbnail pixelpipes. An empty field means that no OpenCL
      device may serve this type of pixelpipe.
    </para>

    <para>
      darktable has an internal numbering system, where the first available OpenCL device will
      receive number <quote>0</quote>. All further devices are numbered consecutively. This
      number together with the device name is displayed when you start darktable with
      <quote>darktable -d opencl</quote>. You can specify a device either by number or by name
      (upper/lower case and whitespace do not matter). If you have more than one
      device&nbsp;&ndash; all with the same name&nbsp;&ndash; you need to use the device numbers
      in order to differentiate them.
    </para>

    <para>
      A device specifier can be preceded by an exclamation mark <quote>!</quote>, in which case
      the device is excluded from processing this pixelpipe. You can also give an asterisk
      <quote>*</quote> as a wildcard, representing all devices not mentioned explicitly before
      in that group.
    </para>

    <para>
      Sequence order within a group matters. darktable will read the list from left to right and
      whenever it tries to allocate an OpenCL device to a pixelpipe it will scan the devices in
      that order, taking the first free device it finds.
    </para>

    <para>
      darktable's default setting for opencl_device_priority is:
    </para>

    <para>
<programlisting>*/!0,*/*/*
</programlisting>
    </para>

    <para>
      Any detected OpenCL device is allowed to process our center view image. The first OpenCL
      device (0) is not allowed to process the preview pixelpipe. As a consequence, if there is
      only one GPU owned by your system, preview pixelpipe will always be processed on CPU,
      keeping your single GPU exclusively for the more demanding center image view. This is
      reasonable and identical to the old behavior. No restrictions apply to export and
      thumbnail pixelpipes.
    </para>

    <para>
      The default is a good choice if you have only one device. If you have several devices it
      forms a reasonable starting point. However, as your devices might have quite different
      levels of processing power, it makes sense to invest a few thoughts and optimize your
      priority list.
    </para>

    <para>
      Here is an example. Let's assume we have a system with two devices, a fast Radeon HD7950
      and an older and slower GeForce GTS450. darktable (started with <quote>darktable -d
      opencl</quote>) will report the following devices:
    </para>

    <para>
<programlisting>[opencl_init] successfully initialized.
[opencl_init] here are the internal numbers and names of 
                          OpenCL devices available to darktable:
[opencl_init]           0       'GeForce GTS 450'
[opencl_init]           1       'Tahiti'
[opencl_init] FINALLY: opencl is AVAILABLE on this system.
</programlisting>
    </para>

    <para>
      So the GeForce GTS 450 is detected as the first device; the Radeon HD7950 ('Tahiti') as
      the second one. This order will normally not change unless the hardware or driver
      configuration is modified. But it's better to use device names rather than numbers to be
      on the safe side.
    </para>

    <para>
      As the GTS450 is slower than the HD7950, an optimized opencl_device_priority could look
      like:
    </para>

    <para>
<programlisting>!GeForce GTS450,*/!Tahiti,*/Tahiti,*/Tahiti,*
</programlisting>
    </para>

    <para>
      The GTS450 is explicitly excluded from doing the center image pixelpipe; this is reserved
      to <quote>all</quote> other devices (i.e. the HD7950/Tahiti). Completely the opposite for
      our preview pixelpipe. Here the Tahiti is excluded, so that only the GTS450 will be
      allowed to do the work.
    </para>

    <para>
      For file export and thumbnail generation we want all hands on deck. However, darktable
      should first look if device Tahiti is free, because it's faster. If that's not the case,
      all other devices&nbsp;&ndash; in fact only the GTS450&nbsp;&ndash; are checked.
    </para>

  </sect2>

  <sect2 status="final">

    <title>OpenCL still does not run for me!</title>

    <para>
      As has been said before OpenCL systems come with a huge variety of setups: different GPU
      manufacturers, different GPU models, varying amounts of GPU memory, different drivers,
      different distributions etc. Many of the potential problems will only appear with a very
      specific combination of those factors.
    </para>

    <para>
      As we developers of darktable on our computers only have access to a small fraction of
      those variations, please understand that we might not be able to fix your specific
      problem. There is not much we can do, if there is no way for us to reproduce.
    </para>

    <para>
      If nothing else helps, the best option might be to start darktable with
    </para>

    <para>
<programlisting>darktable --disable-opencl
</programlisting>
    </para>

    <para>
      In the end there is nothing in darktable which only runs on GPU. Don't let OpenCL
      discourage you; also darktable's CPU code is highly optimized for performance!
    </para>

  </sect2>

</sect1>
